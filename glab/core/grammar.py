"""Definition of grammar base classes.

"""

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from functools import wraps
from typing import Any, Callable, Generator, List, Optional

from glab.core.alphabet import String

log = logging.getLogger("glab.Grammar")


class DerivationSequence(list):
    """Class representing derivation sequence.

    Derivation sequence is list of configurations starting from axiom.

    """


class Strategy(Enum):
    """Derivation strategy

    """

    DFS = "DFS"
    """Depth-First search"""
    IDS = "IDS"
    """Iterative deepening DFS"""
    BFS = "BFS"
    """Breadth-First search"""


@dataclass()
class Configuration:
    """Class representing configuration of grammar.

    Configuration holds all information about state of derivation.
    Grammar should be able to continue derivation only based on data stored in configuration.

    """
    data: Any
    """Arbitrary data that defines configuration.

    Examples:
        - phrase grammar - sential form
        - state grammar - sential form, state
        - pc_grammar_system - configuration for every component

    """
    parent: "Configuration" = None
    """Reference to parent configuration.

    Parent configuration is configuration from which was this configuration derived.
    Only axiom doesn't have parent.

    """
    used_rule: Any = None
    """Justification of derivation step from parent configuration.

    used_rule can be arbitrary data, but for rewriting system it is production that was used.

    """
    affected: Any = None
    """Identifier of affected parts of sential form."""
    depth: int = 0
    """Distance from axiom."""

    def __eq__(self, other):
        return isinstance(other, Configuration) and self.data == other.data

    @property
    @abstractmethod
    def sential_form(self) -> String:
        """Sential form that this configuration represents.

        Language generated by grammar contains all sential forms that are sentences.

        Returns:
            String
        """

    def derivation_sequence(self) -> DerivationSequence:
        """Return sequence of configuration.

        Sequence starts with axiom and results in self.

        """
        if not self.parent:
            return [self]
        return DerivationSequence(self.parent.derivation_sequence() + [self])

    def __repr__(self):
        return f"{self.__class__.__name__}(data={self.data})"


class Rule:
    """Production of grammar

    This class represent one rule of rewriting system.
    Every rule is tried to be matched against current configuration and then applied.

    """

    def apply(self, configuration: Configuration) -> List[Configuration]:
        """Apply production on configuration."""


class Grammar(ABC):
    """Formal grammar

    This class represents formal grammar. Grammar takes configuration and by using rules generates
    new configurations.

    """

    def __init__(self):
        self.filters = []

    def set_filter(self, func: Callable[[Configuration], bool]):
        log.info("Setting filter: %s.", func.__name__)
        self.filters.append(func)

    @property
    @abstractmethod
    def configuration_class(self) -> Configuration:
        """Class representing one configuration.

        Returns:
            Configuration class

        """

    @property
    @abstractmethod
    def axiom(self) -> Configuration:
        """Starting configuration.

        Derivation starts from this configuration

        Returns:
            starting configuration

        """

    @abstractmethod
    def direct_derive(self, configuration: Configuration) -> Generator[Configuration, None, None]:
        """One derivation step.

        Args:
            configuration: Starting configuration

        Returns:
            generator

        Raises:
            NotImplementedError: This method should be implemented in subclass

        """

    def _filter(self, configuration: Configuration):
        for func in self.filters:
            if not func(configuration):
                return False
        return True

    def _dfs_derive(self, axiom: Configuration, depth: int):
        """Depth-First search derivation."""
        log.info("DFS search. (depth=%s)", depth)
        stack = [self.direct_derive(axiom)]
        while stack:
            next_configuration = next(stack[-1], None)
            if next_configuration is None:
                stack.pop()
                continue

            if not self._filter(next_configuration):
                continue

            yield next_configuration

            if next_configuration.sential_form.is_sentence:
                continue

            if len(stack) < depth:
                stack.append(self.direct_derive(next_configuration))

    def _bfs_derive(self, axiom: Configuration, depth: int):
        """Breadth-First search derivation."""
        log.info("BFS search. (depth=%s)", depth)
        queue = [self.direct_derive(axiom)]
        while queue:
            configuration = queue.pop(0)
            for next_configuration in list(configuration):
                if next_configuration.depth > depth:
                    break
                if not self._filter(next_configuration):
                    continue

                yield next_configuration

                if next_configuration.sential_form.is_sentence:
                    continue
                queue.append(self.direct_derive(next_configuration))

    def _ids_derive(self, axiom: Configuration, depth: int = None):
        """Iterative deepening search derivation."""
        current_depth = 0
        while depth is None or current_depth < depth:
            for configuration in self._dfs_derive(axiom, current_depth):
                if configuration.depth == current_depth:
                    yield configuration
            current_depth += 1

    def derive(
        self,
        depth: Optional[int] = None,
        exact_depth: bool = False,
        only_sentences: bool = True,
        strategy: Strategy = Strategy.DFS,
        axiom: Configuration = None,
    ) -> Generator[Configuration, None, None]:
        """Derive from axiom

        Args:
            depth: Maximal depth of derivation. If depth=None, derivation continues indefinitely and IDS is used.
            exact_depth: Yield only configurations with exact depth.
            only_sentences: Yield only sentences.
            strategy: One of DFS, BFS, IDS.
            start: Starting configuration. If start=None, axiom is used.

        Returns:

        """
        log.info(
            "Derivation started. (depth=%s, strategy=%s, exact_depth=%s, only_sentences=%s)",
            depth, strategy.value, exact_depth, only_sentences
        )
        log.info("Axiom: %s", self.axiom)

        if depth is None:
            strategy = Strategy.IDS
            exact_depth = False

        algorithms = {
            Strategy.DFS: self._dfs_derive,
            Strategy.BFS: self._bfs_derive,
            Strategy.IDS: self._ids_derive,
        }

        for configuration in algorithms[strategy](axiom=axiom or self.axiom, depth=depth):
            if exact_depth and depth and configuration.depth != depth:
                continue
            if only_sentences and not configuration.sential_form.is_sentence:
                continue
            yield configuration

    def parse(self, configuration: Configuration, matches: int = 1) -> Generator[Configuration, None, None]:
        """Return configuration with given sential form derived from axiom.

        IDS is used to find configuration with given sential form.
        So this method can take considerable amount of time. This method can be overriden in subclass
        to provide more efficient implementation.
        If grammar doesn't generate configuration with given sential form, method runs indefinitely.

        Args:
            configuration: Configuration with sential form to be parsed.
            matches: Number of matches to be returned.

        Returns:
            Generator of configurations with given sential form.

        """
        for derived_configuration in self.derive(strategy=Strategy.IDS):
            if derived_configuration.sential_form == configuration.sential_form:
                yield derived_configuration
                matches -= 1
                if not matches:
                    break


grammar_restriction = Callable[[Grammar], None]


def restrictions(factory, *conditions: List[grammar_restriction]):
    """Wrapper around grammar factory which ensures that certian conditions are met.

    Args:
        factory: Grammar factory.
        *conditions: List of callables that expect grammar object and raise error if certian condition is not met

    Returns:
        wrapper
    """

    @wraps(factory)
    def wrapper(*args, **kwargs):
        grammar = factory(*args, **kwargs)
        for condition in conditions:
            log.debug("Imposing restriction: %s", condition.__name__)
            condition(grammar)
        return grammar
    return wrapper
